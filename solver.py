import networkx as nx
import networkx.algorithms.approximation.independent_set as nxis
import networkx.algorithms.approximation.clique as nxc
from openopt import STAB, MCP
import numpy as np
import itertools
import argparse
import sys

parser = argparse.ArgumentParser(description="Computes an approximation to the largest orthogonal set, given an interaction matrix as the input")
parser.add_argument('-f', type=str, metavar='FILE', default="random.out", help="path to the interaction matrix, following the format generated by bzipscore-all.py")
parser.add_argument('--target-treshold', type=float, metavar='num', default=-8.5, help="Target interaction score (default -8.5)")
parser.add_argument('--offtarget-treshold', type=float, metavar='num', default=-7, help="Off-target interaction score (default -7)")
parser.add_argument('-n', type=int, metavar='num', default=None, help="Number of peptides")
parser.add_argument('--solver', choices=['openopt', 'networkx'], default='openopt')

args = parser.parse_args()

input_file=args.f 
bonding_positive = args.target_treshold
bonding_negative = args.offtarget_treshold
n = args.n

def parse(line):
    pair=line.split(',')
    return (int(pair[0][1:]), int(pair[1][1:]), float(pair[2]))
if n==None:
    n = 0
    with open(input_file) as fin:
        for line in fin:
            line = line.strip()
            if line!='':
                (i, j, w) = parse(line)
                n = max(n, i, j)
    print("Preliminary scanning done", file = sys.stderr)
    n+=1          

interactions = nx.Graph()
scores = np.zeros(shape=(n+1,n+1), dtype=np.float32)
ids = set()

with open(input_file) as fin:
    for line in fin:
        line = line.strip()
        if line!='':
            (i, j, w) = parse(line)
            if i>j:
                (i, j) = (j, i)
            scores[i][j]=w
            scores[j][i]=w
            if w<bonding_positive:
                interactions.add_node((i, j))

print("Done reading 2", file = sys.stderr)

def will_interact(u, v):
    pairs = itertools.product(u, v)
    #print([scores[p[0]][p[1]] for p in pairs])
    return any([scores[p[0]][p[1]]<bonding_negative for p in pairs])
    #bn = bonding_negative
    #return scores[u[0]][v[0]]<bn or scores[u[0]][v[1]]<bn or scores[u[1]][v[0]]<bn or scores[u[1]][v[1]]<bn
    
def should_connect(u, v):
    if u[0]==v[0] or u[0]==v[1] or u[1]==v[0] or u[1]==v[1] or will_interact(u, v):
    #if (len(set(u)&set(v)) != 0) or will_interact(u, v):
        return True
    else:
        return False

print("Number of nodes: ", interactions.number_of_nodes())

nn = 1
for u in interactions:
    print("Examining node", nn, file = sys.stderr)
    mm = 1
    for v in interactions:
        if u!=v and should_connect(u, v):
            interactions.add_edge(u, v)
        e = interactions.number_of_edges()
        if e>0 and e % 1000 ==0:
            print(e//1000, "k edges", file=sys.stderr)
        mm+=1
    nn+=1

print(interactions.number_of_edges(), "edges in total")

if args.solver=='openopt':
    p = STAB(interactions)
    res = p.manage('glpk')
    solution = res.solution
elif args.solver=='networkx':
    solution = nxis.maximum_independent_set(interactions)
#solution = list(map(lambda x: interactions.node[x]['data'], solution))
solution = list(solution)
    
print(solution)
with open("output.txt", "w") as fout:
    print(solution, file = fout)
